#include "UFAnalyzer.h"
#include "DataFormats/Common/interface/Handle.h"
#include "DataFormats/Common/interface/View.h"
#include "FWCore/Framework/interface/MakerMacros.h"
using namespace std;
using namespace edm;
using namespace reco;
using namespace tools;

UFAnalyzer::UFAnalyzer(const edm::ParameterSet & iConfig)
{
  IT_muon         = iConfig.getParameter<edm::InputTag>("MuonLabel") ;
  IT_electron     = iConfig.getParameter<edm::InputTag>("ElectronLabel") ;
  IT_jet          = iConfig.getParameter<edm::InputTag>("JetLabel");
  IT_pfmet        = iConfig.getParameter<edm::InputTag>("METLabel")  ;
  IT_beamspot     = iConfig.getParameter<edm::InputTag>("BeamSpotLabel");
  IT_hltresults   = iConfig.getParameter<edm::InputTag>("HLTResultsLabel");
  //vMuMu_HLTs   = iConfig.exists("MuMuHLTPaths") ?  iConfig.getUntrackedParameter< std::vector< std::string > > ("MuMuHLTPaths") : std::vector< std::string >(0);
  //vElEl_HLTs   = iConfig.exists("ElElHLTPaths") ?  iConfig.getUntrackedParameter< std::vector< std::string > > ("ElElHLTPaths") : std::vector< std::string >(0);
  //vElMu_HLTs   = iConfig.exists("ElMuHLTPaths") ?  iConfig.getUntrackedParameter< std::vector< std::string > > ("ElMuHLTPaths") : std::vector< std::string >(0);

  value_pfmet      = iConfig.getUntrackedParameter<double>("value_pfmet");

  value_muon_pt    = iConfig.getUntrackedParameter<double>("value_muon_pt");
  value_muon_eta   = iConfig.getUntrackedParameter<double>("value_muon_eta");
  value_muon_chi2Norm = iConfig.getUntrackedParameter<double>("value_muon_chi2Norm");
  value_muon_d0    = iConfig.getUntrackedParameter<double>("value_muon_d0");
  value_muon_nValidHits = iConfig.getUntrackedParameter<int>("value_muon_nValidHits");
  value_muon_reliso= iConfig.getUntrackedParameter<double>("value_muon_reliso");
  value_muon_hadVetoEt = iConfig.getUntrackedParameter<double>("value_muon_hadVetoEt");
  value_muon_emVetoEt = iConfig.getUntrackedParameter<double>("value_muon_emVetoEt");

  value_electron_pt = iConfig.getUntrackedParameter<double>("value_electron_pt");
  value_electron_eta= iConfig.getUntrackedParameter<double>("value_electron_eta");
  bool_electron_crackRemoval = iConfig.getUntrackedParameter<bool>("bool_electron_crackRemoval");
  value_electron_d0 = iConfig.getUntrackedParameter<double>("value_electron_d0");
  bool_electron_chargeConsistency = iConfig.getUntrackedParameter<bool>("bool_electron_chargeConsistency");
  value_electron_reliso = iConfig.getUntrackedParameter<double>("value_electron_reliso");
  value_electron_id = iConfig.getUntrackedParameter<std::string>("value_electron_id");
  bool_electron_ecalDriven = iConfig.getUntrackedParameter<bool>("bool_electron_ecalDriven");
  bool_electron_trackerDriven = iConfig.getUntrackedParameter<bool>("bool_electron_trackerDriven");

  value_jet_multiplicity = iConfig.getUntrackedParameter<int> ("value_jet_multiplicity");
  value_jet_et = iConfig.getUntrackedParameter<double>("value_jet_et");
  value_jet_eta = iConfig.getUntrackedParameter<double>("value_jet_eta");
  bool_jet_id = iConfig.getUntrackedParameter<bool>("bool_jet_id");
  value_jet_leptonVetoDR = iConfig.getUntrackedParameter<double>("value_jet_leptonVetoDR");
  value_ht = iConfig.getUntrackedParameter<double>("value_ht");
  
  value_dilepton_deltaVz = iConfig.getUntrackedParameter<double>("value_dilepton_deltaVz");
  value_dilepton_hfMass= iConfig.getUntrackedParameter<double>("value_dilepton_hfMass");
  bool_dilepton_vetoZ = iConfig.getUntrackedParameter<bool>("bool_dilepton_vetoZ");

  outputFile = TString(  (iConfig.getUntrackedParameter<string>("outputFile")).c_str() );
}


void UFAnalyzer::beginJob()
{
  //book histograms
 MET_DoubleMu_Den = TH1F("MET_DoubleMu_Den", "PFMET", 100, 0., 200.);
 MET_DoubleMu_Num = TH1F("MET_DoubleMu_Num", "PFMET", 100, 0., 200.);
 MET_DoubleEl_Den = TH1F("MET_DoubleEl_Den", "PFMET", 100, 0., 200.);
 MET_DoubleEl_Num = TH1F("MET_DoubleEl_Num", "PFMET", 100, 0., 200.);
 MET_DoubleEM_Den = TH1F("MET_DoubleEM_Den", "PFMET", 100, 0., 200.);
 MET_DoubleEM_Num = TH1F("MET_DoubleEM_Num", "PFMET", 100, 0., 200.);

 HT_DoubleMu_Den = TH1F("HT_DoubleMu_Den", "PFMET", 100, 50., 550.);
 HT_DoubleMu_Num = TH1F("HT_DoubleMu_Num", "PFMET", 100, 50., 550.);
 HT_DoubleEl_Den = TH1F("HT_DoubleEl_Den", "PFMET", 100, 50., 550.);
 HT_DoubleEl_Num = TH1F("HT_DoubleEl_Num", "PFMET", 100, 50., 550.);
 HT_DoubleEM_Den = TH1F("HT_DoubleEM_Den", "PFMET", 100, 50., 550.);
 HT_DoubleEM_Num = TH1F("HT_DoubleEM_Num", "PFMET", 100, 50., 550.);

  hHT  = TH1F("HT", "H_{T}" , 100, 0., 500.);
  hMET = TH1F("MET", "PFMET", 100, 0., 200.);

  hNJets = TH1F("NJets", "Jet Multiplicity", 10, -0.5, 10.);
  hMuonPt = TH1F("MuonPt", "Muon p_{T}", 200, 0., 200.);

}
void UFAnalyzer::endJob()
{
  TFile F(outputFile, "RECREATE");
  F.cd();
  hMET.Write();
  hHT.Write();
  hNJets.Write();
  hMuonPt.Write();  
  MET_DoubleMu_Den.Write(); 
  MET_DoubleMu_Num.Write(); 
  MET_DoubleEl_Den.Write(); 
  MET_DoubleEl_Num.Write(); 
  MET_DoubleEM_Den.Write(); 
  MET_DoubleEM_Num.Write(); 

  HT_DoubleMu_Den.Write();  
  HT_DoubleMu_Num.Write();  
  HT_DoubleEl_Den.Write();  
  HT_DoubleEl_Num.Write();  
  HT_DoubleEM_Den.Write();  
  HT_DoubleEM_Num.Write();    
  F.Close();
}

void UFAnalyzer::analyze(const edm::Event& iEvent, const edm::EventSetup& iEventSetup) 
{

  int run = iEvent.id().run();
  ULong64_t event = iEvent.id().event();
  int lumi = iEvent.luminosityBlock();

//HLT_DoubleMu8_Mass8_PFHT225_v4
//HLT_DoubleMu8_Mass8_PFHT175_v4
//HLT_DoubleEle8_CaloIdT_TrkIdVL_Mass8_PFHT175_v4
//HLT_DoubleEle8_CaloIdT_TrkIdVL_Mass8_PFHT225_v4
//HLT_Mu8_Ele8_CaloIdT_TrkIdVL_Mass8_PFHT175_v3
//HLT_Mu8_Ele8_CaloIdT_TrkIdVL_Mass8_PFHT225_v3

//HLT_Mu14_Ele14_CaloIdT_TrkIdVL_Mass8_PFMET40_v3
//HLT_Mu14_Ele14_CaloIdT_TrkIdVL_Mass8_PFMET50_v3
//HLT_DoubleEle14_CaloIdT_TrkIdVL_Mass8_PFMET40_v3
//HLT_DoubleEle14_CaloIdT_TrkIdVL_Mass8_PFMET50_v3
//HLT_DoubleMu14_Mass8_PFMET40_v4
//HLT_DoubleMu14_Mass8_PFMET50_v4

//HLT_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v16
//HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v4
//HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v4
//HLT_Mu17_Mu8_v16

//if(run < 190782 || run >191202 ) return;

 bool HiggsDouble_Mu = false;
 bool HiggsDouble_El = false;
 bool Higgs_MuEG = false;

 bool Double_Mu_HT = false;
 bool Double_El_HT = false;
 bool Double_MuEG_HT = false;

 bool Double_Mu_MET = false;
 bool Double_El_MET = false;
 bool Double_MuEG_MET = false;
 
   edm::Handle<TriggerResults> trigResults;
   iEvent.getByLabel(IT_hltresults, trigResults);
 
   if( trigResults.failedToGet() ) {
         cout << "--- NO TRIGGER RESULTS !! ---" << endl; 
   }
 
   if( !trigResults.failedToGet() ) {
 
     int N_Triggers = trigResults->size();
 
     const edm::TriggerNames & trigName = iEvent.triggerNames(*trigResults);
 
     for( int i_Trig = 0; i_Trig < N_Triggers; ++i_Trig ) {
 
        if (trigResults.product()->accept(i_Trig)) {  
	   //cout<<i_Trig << " ---Triggers---->> "<<trigName.triggerName(i_Trig)<< endl; 
           TString TrigPath =trigName.triggerName(i_Trig);  
//           TrigPath.ToLower();

	   if( TrigPath.Contains("HLT_Mu17_Mu8_")) 					       HiggsDouble_Mu = true;
	   if( TrigPath.Contains("HLT_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_Ele8_CaloIdT")) HiggsDouble_El = true;
	   if( TrigPath.Contains("HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL") ||
	       TrigPath.Contains("HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL") )          Higgs_MuEG = true;

	   if(TrigPath.Contains("HLT_DoubleMu8_Mass8_PFHT175"))                  Double_Mu_HT = true;
	   if(TrigPath.Contains("HLT_DoubleEle8_CaloIdT_TrkIdVL_Mass8_PFHT175")) Double_El_HT = true;
	   if(TrigPath.Contains("HLT_Mu8_Ele8_CaloIdT_TrkIdVL_Mass8_PFHT175"))   Double_MuEG_HT = true;

	   if(TrigPath.Contains("HLT_DoubleMu14_Mass8_PFMET40"))                 Double_Mu_MET = true;
	   if(TrigPath.Contains("HLT_DoubleEle14"))Double_El_MET = true;
	   if(TrigPath.Contains("HLT_Mu14_Ele14")) Double_MuEG_MET = true;

        }
     }
   }

  edm::Handle< vector<pat::MET> > ThePFMET;
  iEvent.getByLabel(IT_pfmet, ThePFMET);
  const pat::MET *pfmet; 
  if( ThePFMET.isValid() )
    {
      const vector<pat::MET> *pfmetcol = ThePFMET.product();
      pfmet = &(pfmetcol->front());
      if( pfmet->pt() < value_pfmet ) // MET cut
	return ;
    }
  else
    {
      ERR( IT_pfmet );
      return ;
    }

  edm::Handle< reco::BeamSpot > TheBeamSpot;
  iEvent.getByLabel( IT_beamspot, TheBeamSpot );
  reco::BeamSpot bs;
  if( TheBeamSpot.isValid() )
    {
      bs = *TheBeamSpot;
    }
  else 
    {
      ERR( IT_beamspot ) ;
      return ;
    }

  //Pat Muons
  edm::Handle< std::vector<pat::Muon> > ThePatMuons;
  iEvent.getByLabel( IT_muon, ThePatMuons );
  std::vector< const pat::Muon* > vMuons;
  if( ThePatMuons.isValid() ) 
    {
      for( std::vector< pat::Muon>::const_iterator mu = ThePatMuons->begin() ; mu != ThePatMuons->end() ; mu++ ) 
	{
	  if ( mu->pt()  < value_muon_pt ) continue;
	  if ( !mu->isGood( "GlobalMuonPromptTight") ) continue; 
	  if ( !mu->isTrackerMuon() ) continue; 
	  if ( TMath::Abs( mu->eta() ) > value_muon_eta ) continue;
	  const reco::TrackRef innerTrack = mu->innerTrack();
	  if( innerTrack.isNull() ) continue;
	  if( TMath::Abs( innerTrack->dxy( bs.position() ) ) > value_muon_d0 ) continue;
	  if( innerTrack->numberOfValidHits() < value_muon_nValidHits ) continue;
	  const reco::TrackRef globalTrack = mu->globalTrack() ;
	  if( globalTrack.isNull() ) continue;
	  if( globalTrack->normalizedChi2() > value_muon_chi2Norm ) continue;
	  if( mu->isolationR03().emVetoEt > value_muon_emVetoEt ) continue;
	  if( mu->isolationR03().hadVetoEt > value_muon_hadVetoEt ) continue;
	  float RelIso = (mu->isolationR03().emEt + mu->isolationR03().hadEt + mu->isolationR03().sumPt) / mu->pt() ;
	  if( RelIso > value_muon_reliso ) continue;
	  //its a signal-like muon
	  vMuons.push_back(&*mu);
	  hMuonPt.Fill( mu->pt());
	}      
    }
  else
    {
      ERR(IT_muon) ;
      return ;
    }
  
  //Pat Electrons
  edm::Handle< std::vector<pat::Electron> > ThePatElectrons;
  iEvent.getByLabel( IT_electron, ThePatElectrons );
  std::vector< const pat::Electron* > vElectrons;
  if( ThePatElectrons.isValid() )
    {
      for( std::vector<pat::Electron>::const_iterator el = ThePatElectrons->begin() ; el != ThePatElectrons->end() ; el++ ) 
	{
	  if( el->pt() < value_electron_pt ) continue;
	  if( TMath::Abs(el->eta()) > value_electron_eta ) continue;
	  if( bool_electron_crackRemoval ) 
	    if( TMath::Abs(el->eta()) < 1.567 &&  TMath::Abs(el->eta()) > 1.470 ) continue;
	 
	  const reco::GsfTrackRef gsfTrack = el->gsfTrack();
	  if( TMath::Abs( gsfTrack->dxy( bs.position() ) ) > value_electron_d0 ) continue;
	  
	  float ecalIso = TMath::Abs(el->eta()) > 1.47 ? el->dr03TkSumPt() : TMath::Max(el->dr03TkSumPt()-1.,0.); 
	  float RelIso = (el->dr03EcalRecHitSumEt() + el->dr03HcalTowerSumEt() + ecalIso ) / el->pt() ;
	  if( RelIso  > value_electron_reliso ) continue;

	  if( bool_electron_chargeConsistency && !el->isGsfCtfScPixChargeConsistent() )  continue;
	  if( value_electron_id.size() )
	    {
	      int elId =  el->electronID(value_electron_id);
	      if( elId < 4  ) continue;  // just used for conversions, impose isolation, id, seperately...

	      //customized selection from RA5
	      if( el->pt() < 20. )
		{
		  if( ! ( el->fbrem() > 0.15 || ( TMath::Abs( el->superCluster()->eta() ) < 1.0 && el->eSuperClusterOverP() > 0.95 ) ) ) continue;
		}
	      if( TMath::Abs( el->eta() < 1.4442 ) )
		{
		  if( TMath::Abs(el->deltaPhiSuperClusterTrackAtVtx()) > 0.06 ) continue;
		  if( TMath::Abs(el->deltaEtaSuperClusterTrackAtVtx()) > 0.004 ) continue;
		  if( TMath::Abs(el->scSigmaIEtaIEta()) > 0.01 ) continue;
		  if( TMath::Abs(el->hadronicOverEm()) > 0.04 ) continue;
		}
	      else if( TMath::Abs( el->eta() ) < 2.4 ) 
		{
		  if( TMath::Abs(el->deltaPhiSuperClusterTrackAtVtx()) > 0.03 ) continue;
		  if( TMath::Abs(el->deltaEtaSuperClusterTrackAtVtx()) > 0.007 ) continue;
		  if( TMath::Abs(el->scSigmaIEtaIEta()) > 0.03 ) continue;
		  if( TMath::Abs(el->hadronicOverEm()) > 0.1 ) continue;
		}
	    }
	  if( bool_electron_ecalDriven && !el->ecalDrivenSeed() ) continue;
	  if( bool_electron_trackerDriven && !el->trackerDrivenSeed() ) continue;
	  
	  vElectrons.push_back(&*el );
	}
    }
  else
    {
      ERR( IT_electron );
      return ;
    }

  //Pat Jets
  edm::Handle< std::vector< pat::Jet> > ThePatJets;
  iEvent.getByLabel(IT_jet , ThePatJets );
  std::vector< const pat::Jet* > vJets;
  double HT = 0.;
  if( ThePatJets.isValid() )
    {
      for( std::vector<pat::Jet>::const_iterator jet = ThePatJets->begin(); jet != ThePatJets->end(); jet++ ) 
	{
	  if( jet->et() < value_jet_et )continue;
	  if( TMath::Abs( jet->eta() ) > value_jet_eta ) continue;
	  if( bool_jet_id )
	    {
	      if( jet->neutralHadronEnergyFraction() >= 0.99 ) continue;
	      if( jet->neutralEmEnergyFraction() >= 0.99 ) continue;
	      if( ( jet->neutralHadronMultiplicity() + jet->chargedHadronMultiplicity() ) < 2 ) continue;
	      if( TMath::Abs( jet->eta() ) < 2.4 ) 
		{
		  if( jet->chargedHadronEnergyFraction() == 0. ) continue;
		  if( jet->chargedEmEnergyFraction() >= 0.99 ) continue;
		  if( jet->chargedMultiplicity() == 0 ) continue;
		}
	    }

	  bool vetoJet = false;
	  for( std::vector<const pat::Muon*>::const_iterator mu = vMuons.begin(); mu != vMuons.end() ; mu++ )
	    {
	      float dphi = TMath::ACos( TMath::Cos( (*mu)->phi()-jet->phi() ));
	      float deta = (*mu)->eta()-jet->eta();
	      float dr = TMath::Sqrt( dphi*dphi + deta*deta) ;
      	      float RelIso = ((*mu)->isolationR03().emEt + (*mu)->isolationR03().hadEt + (*mu)->isolationR03().sumPt) / (*mu)->pt() ;
	      if( dr < value_jet_leptonVetoDR && RelIso < 0.15)
		{
		  vetoJet = true;
		  break;
		}
	    }
	  if( vetoJet ) continue;
	  for( std::vector<const pat::Electron*>::const_iterator el = vElectrons.begin() ; el != vElectrons.end(); el++ ) 
	    {
	      float dphi = TMath::ACos( TMath::Cos( (*el)->phi()-jet->phi() ) );
	      float deta = (*el)->eta() - jet->eta();
	      float dr = TMath::Sqrt( dphi*dphi + deta*deta );
	      
	      float ecalIso = TMath::Abs((*el)->eta()) > 1.47 ? (*el)->dr03TkSumPt() : TMath::Max((*el)->dr03TkSumPt()-1.,0.); 
	      float RelIso = ((*el)->dr03EcalRecHitSumEt() + (*el)->dr03HcalTowerSumEt() + ecalIso ) / (*el)->pt() ;
	      if( dr < value_jet_leptonVetoDR && RelIso < 0.15) 
		{
		  vetoJet = true;
		  break;
		}
	    }
	  if( vetoJet ) continue;
	  vJets.push_back( &*jet );
	  HT+= jet->et();
	}
    }
  else
    {
      ERR(IT_jet);
      return ;
    }

  // check mass
      double M_mm8 = 0.;
      double M_em8 = 0.;
      double M_ee8 = 0.;
  for(unsigned int i = 0 ; i < vMuons.size() ;i++ ) 
    {
      const pat::Muon *mu_i = vMuons[i];
      for(unsigned int k = i+1 ; k < vMuons.size() ; k++ )
	{
	  const pat::Muon *mu_k = vMuons[k];
	  float m = mass( mu_i->pt() ,  mu_k->pt(), mu_i->eta() , mu_k->eta() ,  mu_i->phi() , mu_k->phi());
	      if( m > value_dilepton_hfMass ) 
		{
		  M_mm8 = m;
		  break;
		}
	}
    }
  for(unsigned int i = 0 ; i < vMuons.size() ;i++ ) 
    {
      const pat::Muon *mu_i = vMuons[i];
      for(unsigned int j = 0 ; j < vElectrons.size() ; j++ )
	{
	  const pat::Electron *el_j= vElectrons[j];
	  float m = mass( mu_i->pt(), el_j->pt(), mu_i->eta(), el_j->eta(), mu_i->phi(), el_j->phi());
	      if( m > value_dilepton_hfMass ) 
		{
		  M_em8 = m;
		  break;
		}
	}
    }

  for(unsigned int i = 0 ; i < vElectrons.size() ;i++ ) 
    {
      const pat::Electron *el_i = vElectrons[i];
      for(unsigned int k = i+1 ; k < vElectrons.size() ; k++ )
	{
	  const pat::Electron *el_k = vElectrons[k];
	  float m = mass( el_i->pt() ,  el_k->pt(), el_i->eta() , el_k->eta() ,  el_i->phi() , el_k->phi());
	      if( m > value_dilepton_hfMass ) 
		{
		  M_ee8 = m;
		  break;
		}
	}
    }

if (vMuons.size() >= 2 && M_mm8 && HiggsDouble_Mu) {
                    MET_DoubleMu_Den.Fill( pfmet->pt() );
  if(Double_Mu_MET) MET_DoubleMu_Num.Fill( pfmet->pt() );

                    HT_DoubleMu_Den.Fill( HT ); 
  if(Double_Mu_HT)  HT_DoubleMu_Num.Fill( HT ); 
}

if (vElectrons.size() >= 2 && M_ee8  && HiggsDouble_El) {

                     MET_DoubleEl_Den.Fill( pfmet->pt() );
  if(Double_El_MET)  MET_DoubleEl_Num.Fill( pfmet->pt() );

  if(pfmet->pt() > 80 ) cout << "**MET"<< pfmet->pt()<<endl;
  if(pfmet->pt() > 80 && !Double_El_MET){
  for(unsigned int i = 0 ; i < vElectrons.size() ;i++ ) 
    {
      const pat::Electron *el_i = vElectrons[i];
	  
	 cout << "pt_El =  "<< el_i->pt() << "  , met= "<<M_ee8<< endl;
  
  }}

                     HT_DoubleEl_Den.Fill( HT ); 
  if(Double_El_HT)   HT_DoubleEl_Num.Fill( HT ); 

}

if ( (vMuons.size() + vElectrons.size())>=2 && M_em8   && Higgs_MuEG) {

 		      MET_DoubleEM_Den.Fill( pfmet->pt() );
  if(Double_MuEG_MET) MET_DoubleEM_Num.Fill( pfmet->pt() );
 		      HT_DoubleEM_Den.Fill( HT ); 
  if(Double_MuEG_HT ) HT_DoubleEM_Num.Fill( HT ); 

}
  hHT.Fill( HT );
  hNJets.Fill( vJets.size() );
  hMET.Fill (pfmet->pt() );
  if( HT < value_ht ) return ;

//  if( vJets.size() < (unsigned int) value_jet_multiplicity ) return ;


  //Get Same-Sign Pairs
  std::vector<event_info>  vSSLeps;

  //First investigate dimuon channel
  for(unsigned int i = 0 ; i < vMuons.size() ;i++ ) 
    {
      const pat::Muon *mu_i = vMuons[i];
      bool ZVeto = false;
      //check for z-veto
      for(unsigned int k = i+1 ; k < vMuons.size() ; k++ )
	{
	  const pat::Muon *mu_k = vMuons[k];
	  if( mu_i->charge() ==  mu_k->charge() ) continue;  // Opp-sign requried for Z-veto
	  float dVz = mu_i->vz() - mu_k->vz();
	  if( TMath::Abs(dVz) > value_dilepton_deltaVz ) continue;	  
	  float m = mass( mu_i->pt() ,  mu_k->pt(), mu_i->eta() , mu_k->eta() ,  mu_i->phi() , mu_k->phi());
	  if( bool_dilepton_vetoZ ) 
	    {
	      if( m > 76.0 && m < 106. ) 
		{
		  ZVeto = true;
		  break;
		}
	    }
	}
      if( ZVeto ) continue;
      
      //search for lepton of same-sign
      for(unsigned int j = i+1 ; j < vMuons.size() ; j++ )
	{
	  const pat::Muon *mu_j= vMuons[j];
	  if( mu_i->charge() != mu_j->charge() ) continue;  //require same-sign
	  float m = mass( mu_i->pt(), mu_j->pt(), mu_i->eta(), mu_j->eta(), mu_i->phi(), mu_j->phi());
	  if( m < value_dilepton_hfMass ) continue; //heavy-flavor mass veto
	  float dVz = mu_i->vz() - mu_j->vz();
	  if( TMath::Abs(dVz) > value_dilepton_deltaVz ) continue;
	  
	  //check second lepton against Z-mass
	  for(unsigned int k = 0 ; k < vMuons.size() ; k++ )
	    {
	      if( j==k ) continue;
	      const pat::Muon *mu_k = vMuons[k];
	      if( mu_j->charge() ==  mu_k->charge() ) continue;  // Opp-sign requried for Z-veto
	      dVz = mu_j->vz() - mu_k->vz();
	      if( TMath::Abs(dVz) > value_dilepton_deltaVz ) continue;
	      m = mass( mu_j->pt() ,  mu_k->pt(), mu_j->eta() , mu_k->eta() ,  mu_j->phi() , mu_k->phi());
	      if( bool_dilepton_vetoZ ) 
		{
		  if( m > 76.0 && m < 106. ) 
		    {
		      ZVeto = true;
		      break;
		    }
		}
	    }	  
	  if( ZVeto ) continue; 

	  //Candidate DiMuon Pair
	  event_info evt;
	  evt.channel = 1;
	  evt.mu.push_back(i);
	  evt.mu.push_back(j);
	  evt.met = pfmet->pt() ;
	  evt.ht = HT;
	  evt.run =run;
	  evt.lumi = lumi;
	  evt.event = event;
	  evt.weight = 1.;
	  vSSLeps.push_back(evt);
	}
    }

  
  //next investigate electron-muon channel
  for(unsigned int i = 0 ; i < vMuons.size() ;i++ ) 
    {
      const pat::Muon *mu_i = vMuons[i];
      bool ZVeto = false;
      //check for z-veto
      for(unsigned int k = i+1 ; k < vMuons.size() ; k++ )
	{
	  const pat::Muon *mu_k = vMuons[k];
	  if( mu_i->charge() ==  mu_k->charge() ) continue;  // Opp-sign requried for Z-veto
	  float dVz = mu_i->vz() - mu_k->vz();
	  if( TMath::Abs(dVz) > value_dilepton_deltaVz ) continue;
	  
	  float m = mass( mu_i->pt() ,  mu_k->pt(), mu_i->eta() , mu_k->eta() ,  mu_i->phi() , mu_k->phi());
	  if( bool_dilepton_vetoZ ) 
	    {
	      if( m > 76.0 && m < 106. ) 
		{
		  ZVeto = true;
		  break;
		}
	    }
	}
      if( ZVeto ) continue;
      
      for(unsigned int j = 0 ; j < vElectrons.size() ; j++ )
	{
	  const pat::Electron *el_j= vElectrons[j];
	  if( mu_i->charge() != el_j->charge() ) continue;  // require same-sign
	  float m = mass( mu_i->pt(), el_j->pt(), mu_i->eta(), el_j->eta(), mu_i->phi(), el_j->phi());
	  if( m < value_dilepton_hfMass ) continue; //heavy-flavor mass veto
	  float dVz = mu_i->vz() - el_j->vz();
	  if( TMath::Abs(dVz) > value_dilepton_deltaVz ) continue;
	  
	  //check second lepton against Z-mass
	  for(unsigned int k = 0 ; k < vElectrons.size() ; k++ )
	    {
	      if( j==k ) continue;
	      const pat::Electron *el_k = vElectrons[k];
	      if( el_j->charge() ==  el_k->charge() ) continue;  // Opp-sign requried for Z-veto
	      dVz = el_j->vz() - el_k->vz();
	      if( TMath::Abs(dVz) > value_dilepton_deltaVz ) continue;
	      m = mass( el_j->pt() ,  el_k->pt(), el_j->eta() , el_k->eta() ,  el_j->phi() , el_k->phi());
	      if( bool_dilepton_vetoZ ) 
		{
		  if( m > 76.0 && m < 106. ) 
		    {
		      ZVeto = true;
		      break;
		    }
		}
	    }	  
	  if( ZVeto ) continue; 

	  //Candidate Electron-Muon Pair
	  event_info evt;
	  evt.channel = 3;
	  evt.mu.push_back(i);
	  evt.el.push_back(j);
	  evt.met = pfmet->pt() ;
	  evt.ht = HT;
	  evt.run =run;
	  evt.lumi = lumi;
	  evt.event = event;
	  evt.weight = 1.;
	  vSSLeps.push_back(evt);
	 
	}
    }

  //next investigate di-electron channel
  for(unsigned int i = 0 ; i < vElectrons.size() ;i++ ) 
    {
      const pat::Electron *el_i = vElectrons[i];
      bool ZVeto = false;
      //check for z-veto
      for(unsigned int k = i+1 ; k < vElectrons.size() ; k++ )
	{
	  const pat::Electron *el_k = vElectrons[k];
	  if( el_i->charge() ==  el_k->charge() ) continue;  // Opp-sign requried for Z-veto
	  float dVz = el_i->vz() - el_k->vz();
	  if( TMath::Abs(dVz) > value_dilepton_deltaVz ) continue;
	  
	  float m = mass( el_i->pt() ,  el_k->pt(), el_i->eta() , el_k->eta() ,  el_i->phi() , el_k->phi());
	  if( bool_dilepton_vetoZ ) 
	    {
	      if( m > 76.0 && m < 106. ) 
		{
		  ZVeto = true;
		  break;
		}
	    }
	}
      if( ZVeto ) continue;
      
      for(unsigned int j = i+1 ; j < vElectrons.size() ; j++ )
	{
	  const pat::Electron *el_j= vElectrons[j];
	  if( el_i->charge() != el_j->charge() ) continue;  // require same-sign
	  float m = mass( el_i->pt(), el_j->pt(), el_i->eta(), el_j->eta(), el_i->phi(), el_j->phi());
	  if( m < value_dilepton_hfMass ) continue; //heavy-flavor mass veto
	  float dVz = el_i->vz() - el_j->vz();
	  if( TMath::Abs(dVz) > value_dilepton_deltaVz ) continue;
	  
	  //check second lepton against Z-mass
	  for(unsigned int k = 0 ; k < vElectrons.size() ; k++ )
	    {
	      if( j==k ) continue;
	      const pat::Electron *el_k = vElectrons[k];
	      if( el_j->charge() ==  el_k->charge() ) continue;  // Opp-sign requried for Z-veto
	      dVz = el_j->vz() - el_k->vz();
	      if( TMath::Abs(dVz) > value_dilepton_deltaVz ) continue;
	      m = mass( el_j->pt() ,  el_k->pt(), el_j->eta() , el_k->eta() ,  el_j->phi() , el_k->phi());
	      if( bool_dilepton_vetoZ ) 
		{
		  if( m > 76.0 && m < 106. ) 
		    {
		      ZVeto = true;
		      break;
		    }
		}
	    }	  
	  if( ZVeto ) continue; 

	  //Candidate DiElectron Pair
	  event_info evt;
	  evt.channel = 2;
	  evt.el.push_back(i);
	  evt.el.push_back(j);
	  evt.met = pfmet->pt() ;
	  evt.ht = HT;
	  evt.run =run;
	  evt.lumi = lumi;
	  evt.event = event;
	  evt.weight = 1.;
	  vSSLeps.push_back(evt);
	}
    }

  
}

DEFINE_FWK_MODULE(UFAnalyzer);
